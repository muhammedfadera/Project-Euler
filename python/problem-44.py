"""
Pentagonal numbers are generated by the formula:

P_n = n(3n - 1) / 2

The first ten pentagonal numbers are:

1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

It can be seen that P_4 + P_7 = 22 + 70 = 92 = P_8. However, their difference, 70 - 22 = 48, is not pentagonal.

Find the pair of pentagonal numbers, P_j and P_k, for which their sum and difference 
are pentagonal and D = |P_k - P_j| is minimised; what is the value of D?

Approach:
    So we want 
    P_j + P_k = P_l 
    P_j - P_k = P_m
    then 
    P_l = (P_j + P_k)/2
    P_m = (P_j - P_k)/2

    So either both P_j and P_k are even or both are odd. For j = n + k and k = n,
    if we analyse the difference
    P_j - P_k = (n + k)(3(n+k) - 1) / 2 - n(3n - 1) / 2 = (6nk + 3k - k^2),

    we see that for any fixed value of n, the value of k which minimises the difference
    is k = (6n + 1)/6. Thus we must only search for values of k for which (6n + 1)
    is divisble by 6. 

    We compare successive pentagonal numbers
    during each iteration we take note of the difference
    in successive iteration we only check if the difference 
"""
#%%
from math import ceil, sqrt
def is_pentagonal(x):
    n, remainder = divmod(1 + sqrt(1 + 24*x), 6)
    if remainder == 0:
        return True
    return False
def pentagonal(n):
    return n*(3*n - 1)/2

def get_n(x):
    sqrt_x = sqrt((1 + 24*x))
    return (1 + sqrt_x)/6

def check_both_even_odd(x, y):
    return (x % 2 == 0) == (y % 2 == 0)

def is_sqrt_cond(P_m, n):
    P_m_sqrt = sqrt((6*n-1)**2 + 24*P_m)
    if int(P_m_sqrt) - P_m_sqrt == 0:
        return P_m_sqrt
    else:
        return 0
def largest_k(P_m):
    return ceil(1 + sqrt(1 + 24*P_m))

def largest_n(P_m):
    return ceil((24*P_m - 3 + 1)/6)

def diff_P(n, k):
    return 0.5*(6*n*k + 3*k**2 - k)

#%%
import time

t1 = time.time()

n = 3
D_min = float('inf')
cond = False
# while n > 3:
while not cond:
    P_j = pentagonal(n)
    for k in range(1, n-1):
        # print(f"compairing {k} and {n-1}")
        P_k = pentagonal(k)
        D = P_j - P_k
        if check_both_even_odd(P_k, P_j) and \
          is_pentagonal(D) and is_pentagonal(P_k + P_j):
            cond = True
            D_min = min(D, D_min)
            # print(k)
            # print(n)
            break
    n += 1

print(f"The minimum difference {int(D_min)}")
t2 = time.time()
print(f"Time taken: {t2 - t1: .2f}")
#%%
# %%
# n = get_n(D_min)
m = 0
cond = False
while not cond:
    # P_m is the possible difference
    m += 1
    P_m = pentagonal(m)
    n_max = P_m
    n = 1
    while n <= P_m:
        k, remainder = divmod(1-6*n + sqrt((6*n - 1)**2 + 24*P_m), 6)
        P_n = pentagonal(n)
        P_n_k = pentagonal(n + k)
        if remainder == 0 and is_pentagonal(P_n_k + P_n):
            # print(f"checking difference")
            print("The minimum is attained at the pentagonal numbers",
                  f"{P_n} and {P_n_k} with a differnce of {P_n_k - P_n}")
            cond = True
            break
        n += 1
    



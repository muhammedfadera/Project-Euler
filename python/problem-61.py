"""
Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are 
all figurate (polygonal) numbers. They are generated by the following formulas:

* Triangle numbers:
  Formula: P(3, n) = n × (n + 1) / 2
  First few values: 1, 3, 6, 10, 15, ...

* Square numbers:
  Formula: P(4, n) = n × n
  First few values: 1, 4, 9, 16, 25, ...

* Pentagonal numbers:
  Formula: P(5, n) = n × (3n - 1) / 2
  First few values: 1, 5, 12, 22, 35, ...

* Hexagonal numbers:
  Formula: P(6, n) = n × (2n - 1)
  First few values: 1, 6, 15, 28, 45, ...

* Heptagonal numbers:
  Formula: P(7, n) = n × (5n - 3) / 2
  First few values: 1, 7, 18, 34, 55, ...

* Octagonal numbers:
  Formula: P(8, n) = n × (3n - 2)
  First few values: 1, 8, 21, 40, 65, ...


The ordered set of three 4-digit numbers — 8128, 2882, 8281 — has three interesting properties:

1. The set is cyclic, meaning the last two digits of each number match the first 
   two digits of the next number, and this pattern wraps around from the last number back to the first.
2. Each number comes from a different polygonal number type:
   * 8128 is a triangle number (P(3,127))
   * 2882 is a pentagonal number (P(5,44))
   * 8281 is a square number (P(4,91))
3. This is the only known set of three 4-digit numbers with these properties.


Question

Find the sum of the only known ordered set of six cyclic 4-digit numbers, where:

* Each number belongs to a different type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal.
* The set is cyclic
* Each polygonal type is used exactly once.

What is the sum of these six numbers?

"""
#%%
from time import time
t1 = time()
from utilities import triangular, square, pentagonal, hexagonal, heptagonal, octagonal
from utilities import factorial, is_int
from math import log10, isqrt, sqrt
from itertools import permutations, combinations_with_replacement

n_oct = lambda x: (2 + (4 + 4*3*x)**0.5)/6
is_octagonal = lambda x: is_int(n_oct(x))
n_hept = lambda x: (3/2 + ((3/2)**2 + 4*5/2*x)**0.5)/5
is_heptagonal = lambda x: is_int(n_hept(x))
n_hex = lambda x: (1 + (1 + 4*2*x)**0.5)/4
is_hexagonal = lambda x: is_int(n_hex(x))
n_pent = lambda x: (1/2 + ((1/2)**2 + 4*3/2*x)**0.5)/3
is_pentagonal = lambda x: is_int(n_pent(x))
n_sq = lambda x: x**0.5
is_square = lambda x: is_int(n_sq(x))
n_tr = lambda x: (-1/2 + ((1/2)**2 + 4*1/2*x)**0.5)
is_triangular = lambda x: is_int(n_tr(x))


unique_number_types = {8: is_octagonal, 
					   7: is_heptagonal,
					   6: is_hexagonal,
					   5: is_pentagonal,
					   4: is_square,
					   3: is_triangular}

def generate_number_list(x):
	"""
	x is a number represented as a string
	generate a sequence of length equal to half of len(x)
	generate_number_list('818234') = [8182, 8234]
	"""
	res = []
	n = len(x)
	for i in range(n//2-1):
		res.append(int(x[2*i:(2*i+4)]))	
	return res



def check_unique_number_type(number_list, n_digits = 4, hard_check = False):
	"""
	checks the possible number types in number_list
	"""
	digits_cond = sum(len(str(x)) == n_digits for x in number_list)
	if digits_cond != len(number_list):
		return False, []

	curr_number_types = set(range(3, 9))
	counter = 0
	actual_number_types = []
	for x in number_list:
		cond = [i for i in curr_number_types if unique_number_types[i](int(x))]
		if len(cond) != 0:
			curr_number_types = curr_number_types.difference(cond)
			counter += 1
			actual_number_types.append(tuple(cond))
		elif hard_check:
			break
	if counter == len(number_list):
		return True, actual_number_types
	else:
		return False, []
# solution begins

n_terms = 3 # we want to check all possible pairs
n_digits = 2*n_terms
start = int('1' + '0'*(n_digits - 1))
end = int('9'*n_digits)


def form_number_string(even_index, odd_index, length = n_digits):
	"""
	given a choice of digits at even numbered index and odd numbered 
	index, return the number. 
	This split is used here because 0 cannot be an odd numbered index since
	that would mean one of the numbers in the list is 3 digits
	"""
	res = ''
	even_ix = 0
	odd_ix = 0
	for i in range(length):
		if i % 2 == 0:
			res += str(odd_index[odd_ix])
			odd_ix += 1
		else:
			res += str(even_index[even_ix])
			even_ix += 1
	return res

def are_keys_compatible(k1, k2):
	"""
	checks if the numbers types in k1 is not repeated in k2
	"""
	more_than_one_idx_k1 = []
	for idx in k1:
		if idx in k2:
			if len(idx) == 1:
				if idx in k2:
					return False
		else:
			more_than_one_idx_k1.append(idx)
	for idx in more_than_one_idx_k1:
		l = 0
		while l < len(idx):
			curr_idx = idx[l]
			if (curr_idx,) in k2:
				return False
			l += 1
	return True

# solutions starts
odd_numbered_index = combinations_with_replacement(range(1, 10), n_digits//2)
even_numbered_index = combinations_with_replacement(range(10), n_digits//2)
even_numbered_index = combinations_with_replacement(range(10), n_digits//2)
odd_permutations = set()
for odd_idx_combinations in odd_numbered_index:
	odd = set(permutations(odd_idx_combinations))
	odd_permutations.update(odd)

even_permutations = set()
for even_idx_combinations in even_numbered_index:
	even = set(permutations(even_idx_combinations))
	even_permutations.update(even)

all_pairs = set()
for odd_idx in odd_permutations:
	for even_idx in even_permutations:
		if even_idx != odd_idx:
			number_string = form_number_string(even_idx, odd_idx, n_digits)
			number_list = generate_number_list(number_string)
			if len(list(number_list)) == 2:
				cond, number_types = check_unique_number_type(number_list, hard_check=False)
				if cond:
					ks_tail = str(number_list[1])
					ks_head = str(number_list[0])
					ks_number_types = (number_types[0], number_types[1])
					all_pairs.add((ks_head, ks_tail, ks_number_types))
				

sextuples = set()
break_cond = False
for k1 in all_pairs:
	for k2 in all_pairs:
		if k1 != k2 and k1[1][2:] == k2[0][:2] and \
				are_keys_compatible(k1[2], k2[2]):
			for k3 in all_pairs:
				if k2 != k3 and k3 != k1 and \
				    k2[1][2:] == k3[0][:2] and \
					k3[1][2:] == k1[0][:2] and \
					are_keys_compatible((*k1[2], *k2[2]), k3[2]):
					# 1. check that if a number is of multiple types, you 
					# can only choose it at most that number times. 
					count_check = [*k1[2], *k2[2], *k3[2]]
					counts = [count_check.count(x) for x in count_check]
					if 3 not in counts:
						y = set()
						for ix in count_check:
							y.update(ix)
						if y == set(range(3, 9)): # ensures all number types included
							sextuples.add((*k1[:2], *k2[:2], *k3[:2], (*k1[2], *k2[2], *k3[2])))
							print("solution found!")
							break_cond = True
							break
			if break_cond:
				break
		if break_cond:
			break
	if break_cond:
		break
print(f"The required sequence is {*k1[:2], *k2[:2], *k3[:2]} with number types {*k1[2], *k2[2], *k3[2]}")
print(f"Their sum is {sum(int(d) for d in [*k1[:2], *k2[:2], *k3[:2]])}")
print(f"Time taken: {time() - t1: .2f} seconds")
#%% fast solution from project euler thread
# def calc_numbers(start, end, proc):
#     n = 1
#     out = []
#     while True:
#         z = proc(n)
#         if z >= start and z < end:
#             out.append(int(z))  # Ensure integer values
#         if z >= end:
#             return out
#         n += 1

# p3 = calc_numbers(1000, 10000, lambda n: n * (n + 1) / 2)
# p4 = calc_numbers(1000, 10000, lambda n: n * n)
# p5 = calc_numbers(1000, 10000, lambda n: n * (3 * n - 1) / 2)
# p6 = calc_numbers(1000, 10000, lambda n: n * (2 * n - 1))
# p7 = calc_numbers(1000, 10000, lambda n: n * (5 * n - 3) / 2)
# p8 = calc_numbers(1000, 10000, lambda n: n * (3 * n - 2))

# def find_loop(lists, start, end, found_numbers=None):
#     if found_numbers is None:
#         found_numbers = []
        
#     if len(lists) == 1 and (start * 100 + end) in lists[0]:
#         found_numbers += [start * 100 + end]
#         print(found_numbers, sum(found_numbers))
#         raise SystemExit()  # cleaner than 1/0 for exiting

#     for cur_list in lists:
#         for c in cur_list:
#             if c // 100 == start:
#                 lists_copy = lists.copy()
#                 lists_copy.remove(cur_list)
#                 find_loop(lists_copy, c % 100, end, found_numbers + [c])

# for n in p8:
#     find_loop([p3, p4, p5, p6, p7], n % 100, n // 100)
